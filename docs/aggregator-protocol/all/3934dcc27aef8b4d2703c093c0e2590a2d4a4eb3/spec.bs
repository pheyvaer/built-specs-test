<pre class="metadata">
Title: Aggregator Specification
Shortname: aggregator-spec
Level: none
Status: LD
Editor: Maarten Vandenbrande, Ghent University - imec http://idlab.ugent.be/, maarten.vandenbrande@ugent.be
Abstract: This document has the specification of the aggregator.
Markup Shorthands: markdown yes, css no
Local Boilerplate: logo yes
Canonical URL: _ORCHESTRATOR_CURRENT_BUILD_FULL_LINK_
Previous Version: _ORCHESTRATOR_PREVIOUS_BUILD_FULL_LINK_
</pre>

<pre class="anchors">
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/#
    type: dfn; text: server-sent events
</pre>

<!-- Content -->

Introduction {#introduction}
============================

The introduction for the Aggregator specification will be expanded in future revisions.



Definitions {#definitions}
==========================

add a link to other specs used: WebID, OIDC, UMA

- IDP Server (IDPS): An Identity Provider server that supports OIDC and issues OIDC tokens.

NOTE: that this is different from the Authorization Server (AS) that issues UMA RPT tokens.
The IDP Servers are used to provide identity to users.
The Authorization Servers checks this identity and issues RPT tokens for resource servers.

- Authorization Server (AS): An OAuth2 Authorization Server that supports UMA and issues RPT tokens.

- Resource Server (RS): An OAuth2 Resource Server that protects resources and accepts RPT tokens issued from a Authorization Server.
- Aggregator Server: A server that hosts multiple Aggregators.
- Aggregator: A service that manages multiple Aggregator Services and allows user to create and use them.
- Aggregator Service: A service that aggregates data from multiple Resource Servers on behalf of a user.
- Client: An application that interacts with the Aggregator Service.
- ClientID: A JSON-LD document that describes a Client. It is dereferenceable via a URL.
- User: A person who owns resources on Resource Servers and uses the Client and Aggregator.
- OIDC token
- Authorization server
- Resource server



Public Metadata {#public-metadata}
=================================

`./.well-known/aggregator-configuration` {#aggregator-configuration}
---------------------

Endpoint that exposes the public metadata about the aggregator server.
This endpoint MUST be accessible without authentication and provide at least the following information in JSON format:
- **registration_endpoint:** The URL of the registration endpoint ([[#registration-endpoint]]).
- **supported_registration_types:** A list of strings that are valid registration types supported by the server (e.g., "client_credentials", "authorization_code") ([[#registration-endpoint]]).
- **version:** The version of the aggregator specification that the server adheres to.

`./client.json` {#client-json}
---------------------

Endpoint that exposes the client identifier used for authorization.


`./transformations` {#transformations}
---------------------

This endpoint returns a RDF document describing the transformations supported by the aggregator server on a server level.
This RDF document SHOULD be exposed using content negotiation based on HTTP.
The transformations MUST be described using FnO.

<div class="example">
```turtle
@prefix trans: <http://aggregator.example.org/transformations>
@prefix fno: <https://w3id.org/function/ontology#>
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

trans:AggregateSources
    a                   fno:Function ;
    fno:name            "A Aggregator Service that combines a list of sources"^^xsd:string ;
    fno:expects         ( trans:Sources ) ;
    fno:returns         ( trans:Result ) .

trans:Sources
    a             fno:Parameter ;
    fno:predicate trans:sources ;
    fno:type      rdf:List ;
    fno:required  "true"^^xsd:boolean.

trans:Result
    a             fno:Output ;
    fno:predicate trans:result ;
    fno:type      xsd:string .
```
</div>

The specificity of the transformation is up to the server owner.
The transformations CAN have a link to a implementation with `fno:Implementation` if needed.
External FnO functions MAY be used using `rdfs:seeAlso`.
Pre defined pipelines MAY be used using `fno:Compositions`.

ISSUE: TODO how do we allow an aggregator that can run any transformation?



Registration Endpoint {#registration-endpoint}
=====================
This section describes how aggregators are managed on the Aggregator Server level.
The authorization for these endpoints is defined by the implementation and up to the Aggregator provider to decide.
The user requires authenticated requests to manage their aggregator accounts on wich the Aggregator provider can base their authorization decisions.
The tokens used in these requests (IPD_client_token) prove the identity of the user and the client (ClientID) used to access the aggregator.

ISSUE: TODO add a defenition of the endpoint here, after we go into the flows of how they are used.

ISSUE: TODO add that after creation the aggregator should register the resources to the AS.

Aggregator Creation {#aggregator-creation}
---------------------
This section describes how clients can create an Aggregator.
There exists different flows to create an aggregator depending on the registration type.

ISSUE: TODO where to add versioning info?

ISSUE: TODO where to use DPOP tokens?

ISSUE: TODO what about HTTP error handling?

ISSUE: TODO mention that the aggregator can be either host based or path based: {id}.aggregator.org or aggregator.org/{id}/

ISSUE: TODO the result of aggregator creation returns the ID and the base url of the aggregator (for example {id}.aggregator.org or aggregator.org/{id}/).

### `provision` Flow ### {#creation-provision}

The `provision` flow allows clients to create an Aggregator with its own identity.
This lets resource owners target access-control policies at the aggregator’s dedicated WebID instead of having the aggregator impersonate another user’s WebID.

**1. Client starts flow with Aggregator Server**

The client calls the registration endpoint authenticated with its `IPD_client_token`.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "provision",
}
```
</div>

**2. Aggregator Server provisions a WebID and registers it at the IDP**

The Aggregator Server creates a WebID document and registers a new account with an IDP for that WebID.
Using the credentials of this new account the Aggregator Server CAN perform a client credentials flow to obtain the `IDP_aggregator_token` (and accompanying refresh token) to authorize the aggregator acting under its own WebID.

ISSUE: TODO should this WebID specify that it is an aggregator/agent?

**3. Aggregator Server creates an aggregator**

Using the obtained tokens, the Aggregator Server creates an aggregator linked to the user, and returns the aggregator metadata and newly created WebID.
The aggregator CAN NOT give these tokens or client credentials to the client.


### `authorization_code` Flow ### {#creation-authorization}

The `authorization_code` flow allows clients to create an aggregator that acts on behalf of the end-user, but with a token that is scoped specifically for the aggregator.

<img src="uml/f89d15189bc77457ba4b37e36b7f67ec4b246993.svg" alt="PlantUML Diagram" no-autosize>

**1. Client starts flow with Aggregator Server**

The client begins by asking the Aggregator to bootstrap an authorization_code registration and indicate which authorization server should be used. The Aggregator responds with the public parameters required for the OIDC authorization request.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "authorization_server": "https://as.example"
}
```
</div>

**1.1 Aggregator dereferences the WebID to discover the IDP**

Using the UMA authorization context, the Aggregator dereferences the user’s WebID profile document to locate the Solid/OIDC issuer metadata and determine which IDP endpoints must be used for the next steps.

**1.2 Aggregator responds with public parameters**

After finishing WebID discovery and storing the PKCE verifier/state, the Aggregator returns the public parameters required for the IDP authorization request.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "client_id": "https://aggregator.example/client.jsonld",
  "code_challenge": "1uLSZp2...",
  "code_challenge_method": "S256",
  "state": "1eb7c8f5..."
}
```
</div>

The Aggregator generates the PKCE verifier/challenge pair plus a random `state`, persists them together with the pending registration, and returns only the public portions (`client_id`, `code_challenge`, `state`) to the client application.
The `authorization_server` value identifies the UMA Authorization Server (AS) that governs resource policies; once the Aggregator evaluates the user’s authorization token it can dereference its WebID and determine which Identity Provider (IDP) must be used for the subsequent OIDC exchange.

ISSUE: TODO How does the aggregator register with the AS?

**2. Client sends the end-user through the IDP authorization endpoint**

Using the information supplied by the Aggregator, the client constructs an authorization request against the Identity Provider.
The redirect_uri is under control of the client application and MUST already be registered in the JSON-LD client metadata document hosted at the dereferenceable `client_id`.

<div class="example">
```http
GET https://idp.example/authorize?
    response_type=code&
    client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
    redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
    scope=openid%20webid%20offline_access&
    code_challenge=1uLSZp2...&
    code_challenge_method=S256&
    state=1eb7c8f5...
```
</div>

**3. User authenticates and consents at the IDP**

The IDP performs its usual login and consent screens, after which it issues an authorization_code tied to the Aggregator’s confidential client.

**4. IDP redirects the user agent back to the client’s redirect_uri**

<div class="example">
```http
HTTP/1.1 302 Found
Location: https://app.example/callback?code=SplxlOBeZQQYbYS6WxSbIA&state=1eb7c8f5...
```
</div>

**5. Client posts the authorization code back to the Aggregator**

The client sends the code, redirect URI, and echoed state to the registration endpoint so the Aggregator can finish the flow.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "code": "SplxlOBeZQQYbYS6WxSbIA",
  "redirect_uri": "https://app.example/callback",
  "state": "1eb7c8f5..."
}
```
</div>

**5.1 Aggregator dereferences the client metadata**

The Aggregator dereferences the `client_id` JSON-LD document to confirm the registered redirect URIs, contact metadata, and other security requirements, then verifies that the supplied redirect_uri belongs to that set and that the returned `state` matches the stored nonce.

**5.2 Aggregator redeems the authorization code at the IDP token endpoint**

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <aggregator-client-auth>

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
code_verifier=Hjs8...stored...
```
</div>

The IDP verifies the authorization_code, ensures the redirect_uri matches the original authorization request, and recomputes the PKCE challenge from the supplied `code_verifier`. If everything matches, it returns:

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 3600
}
```
</div>

**5.3 Aggregator finalizes the account and responds**

Using the issued tokens, the Aggregator creates the aggregator account linked to the user and returns the aggregator account details to the client.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator_id": "agg-7890",
  "authorization_server": "https://as.example",
}
```
</div>


### `client_credentials` Flow ### {#creation-client-credentials}

The `client_credentials` flow allows clients to create an aggregator by using the OAuth2 Client Credentials Flow to obtain an OIDC token from an Identity Provider (IDP) server.

NOTE: This flow gives the aggregator complete access to the user's resources and policies without user consent.
This flow should only be used in trusted environments, or when a user creates an account for the aggregator.

**1. Client starts flow with Aggregator Server**

The client explicitly asks the Aggregator to act with full credentials for the provided WebID, indicating which UMA Authorization Server manages the protected resources.
Because this flow hands the Aggregator long-lived credentials, it should only be used when the user intentionally provisions the Aggregator as a trusted service account.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "client_credentials",
  "authorization_server": "https://as.example",
  "webid": "https://user.example/webid#me",
  "username": "alice@example.org",
  "password": "s3cr3t-password"
}
```
</div>

**2. Aggregator Server performs credential bootstrap with the IDP**

The Aggregator uses the supplied username/password (plus the WebID context) to authenticate against the Identity Provider’s management or token endpoint, registering (or reusing) a confidential client that represents the Aggregator’s service account for that user. It then runs an OAuth 2.0 client_credentials grant using the obtained client_id/client_secret to mint an `IDP_aggregator_token` scoped to the user’s WebID.

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <aggregator-client-auth>

grant_type=client_credentials&
webid=https%3A%2F%2Fuser.example%2Fwebid%23me&
scope=openid%20webid%20offline_access
```
</div>

The IDP issues access and refresh tokens that grant the Aggregator the same capabilities as the user’s own credentials.

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 7200
}
```
</div>

**3. Aggregator Server creates (or updates) the aggregator account**

Armed with the `IDP_aggregator_token`, the Aggregator persists the account for the specified WebID, associates it with the requesting user, and returns the aggregator account metadata (aggregator identifier, token expiry, UMA AS linkage, etc.) to the client.


### `device_code` Flow ### {#creation-device-code}

NOTE: TODO This flow is not yet specified.

Aggregator Login {#aggregator-login}
-------------------
The login flow allows users to update the tokens of their existing aggregator.
This flow can be used to refresh the tokens in case they have expired.
The flow is the same as with creating an aggregator but an aggregator_id parameter is provided in step 1.
The exact steps depend on the registration_type used when creating the aggregator.
For example for the `authorization_code` flow:

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json
{
    "registration_type": "authorization_code",
    "aggregator_id": "agg-7890"
}
```
</div>

Aggregator Deletion {#aggregator-deletion}
-------------------
The delete flow allows users to delete their existing aggregator.
This flow is done by doing a DELETE request to the registration endpoint with the aggregator_id parameter.

<div class="example">
```http
DELETE /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json
{
    "aggregator_id": "agg-7890"
}
```
</div>



Authentication {#authentication}
===============================

This section describes how the Aggregator handles authentication and authorization for:

- outgoing requests from the Aggregator to upstream Resource Servers; and
- incoming requests from Clients to the Aggregator.

The Aggregator relies on the Authorization for Data Spaces (A4DS) specification to authenticate Clients and authorize access to resources.
For streaming or non-HTTP interfaces, the Aggregator MAY additionally use the Service Authorization for Data Spaces (SA4DS) specification.
All Aggregator endpoints are protected using User-Managed Access (UMA).

NOTE: The following behavior extends the A4DS specification and is intended to be incorporated in a future version of A4DS.

Requesting Flow {#requesting-flow}
---------------------------------

ISSUE: TODO: how does the Aggregator tell the Authorization Server (AS) which transformation it intends to perform on the data?

Equipped with an identity token (ID token) from an Identity Provider (IdP) as described in [[#registration-endpoint]], the Aggregator Service follows the Authorization for Data Spaces (A4DS) specification to obtain access tokens for upstream Resource Servers.

<img src="uml/d75e5ec61c587df74d72d9c247374bed8f39b22f.svg" alt="PlantUML Diagram" no-autosize>

**1. Requesting the upstream resource without token**
The Aggregator Service requests the upstream resource without an access token. If the resource is protected with UMA, the Upstream Resource Server responds with a `401 Unauthorized` status and a UMA ticket.

<div class="example">
```http
GET /resource/123 HTTP/1.1
Host: upstream.example.org
```
</div>

**1.1 Upstream Resource Server requests ticket from Upstream Authorization Server**

The Upstream Resource Server requests a UMA ticket from its Upstream Authorization Server.

**1.2 Upstream Resource Server returns ticket**

The Upstream Resource Server returns the UMA ticket to the Aggregator Service.

<div class="example">
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="solid", as_uri="https://upstream.as.example.org/uma", ticket="tkt-URS"
```
</div>

**2. Requesting an access token from the Upstream Authorization Server**

Using the ID token obtained from the IdP during registration, the Aggregator Service requests an access token from the Upstream Authorization Server (of the Upstream Resource Server).
In this request, the Aggregator Service SHOULD request the additional scope `urn:knows:uma:scopes:derivation-creation` to enable the Aggregator functionality.
The Upstream Authorization Server MAY require additional claims to issue the access token.

ISSUE: TODO: if this resource has already been requested, the Upstream Authorization Server already has a `derivation_resource_id` for this Aggregator. Does the Aggregator need to request a new one, or can it reuse the existing one? 

<div class="example">
```http
POST /token HTTP/1.1
Host: upstream.as.example.org
Content-Type: application/json
{
    "grant_type": "urn:ietf:params:oauth:grant-type:uma-ticket",
    "ticket": "tkt-URS",
    "scope": "urn:knows:uma:scopes:derivation-creation"
    "claim_token": "IDP_aggregator_token",
    "claim_token_format": "http://openid.net/specs/openid-connect-core-1_0.html#IDToken",
}
```
</div>
**2.1 Upstream Authorization Server validates the ID token**

The Upstream Authorization Server validates the ID token with the Identity Provider that issued it.

**2.2 Upstream Authorization Server returns access token and derivation resource identifier**

Adding the derivation-creation scope signals to the Authorization Server that the Aggregator intends to create a derived resource based on the requested upstream resource.
The Authorization Server MUST then include a `derivation_resource_id` in the response.
The `derivation_resource_id` is a unique identifier that the Aggregator will use to reference this upstream resource when creating derived resources.
The Authorization Server can link this identifier to the Aggregator's identity to manage and track derived resources.

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json
{
    "access_token": "uas-at",
    "derivation_resource_id": "handle-id-1"
}
```
</div>

**3. Accessing the upstream resource with token**

The Aggregator Service then requests the resource from the Upstream Resource Server using the access token obtained from the Upstream Authorization Server.
This access token MAY be used multiple times until it expires or is revoked.

**4. Resource registration of the Aggregator Service**

Finally, the Aggregator Service MUST update the resource registration at its own Authorization Server to signal that it used this `derivation_resource_id` to create derived resources.
The Authorization Server MUST expire all previous access tokens for this resource.

<div class="example">
```http
PUT /resource-registration/agg-service-123 HTTP/1.1
Host: as.example.org
Content-Type: application/json
{
  ...
    "resource_relations": {
          "prov:wasDerivedFrom": {
              "issuer": "https://as.example.org",
              "derivation_resource_id": "handle-id-1"
          }
        }
    }
```
</div>

If a resource isn't used anymore by the Aggregator Service, the Aggregator Service SHOULD update the resource registration to remove the `derivation_resource_id` from the `prov:wasDerivedFrom` relations, and MAY expire all previous access tokens for this resource.
Also the Aggregator Service SHOULD delete the resource from its Upstream Resource Server, by following the Resource ID deletion procedure.

Serving Flow {#serving-flow}
---------------------------------

When a Client requests access to resources from the Aggregator Service, the Aggregator Service acts as a Resource Server and relies on UMA to authorize access.
For each incoming request:

1. The Client sends a request for a (derived) resource to the Aggregator Service, with or without a valid access token.
2. The Aggregator Service requests a UMA ticket for that resource from its Authorization Server and, if necessary, returns a `401 Unauthorized` response containing the ticket to the Client.
3. The Client interacts with the Aggregator Authorization Server (and, if required, upstream Authorization Servers) to obtain the access tokens needed to access the derived resource.
4. Once authorization succeeds, the Client retries the request to the Aggregator Service with a valid access token, and the Aggregator Service returns the derived resource.

<img src="uml/5b3d1a9048733b39382e6f8a5d825d8c05cb42c9.svg" alt="PlantUML Diagram" no-autosize>

**1. Client requests derived resource from Aggregator Service without token**
The Client sends a request to the Aggregator Service for a derived resource without including a valid Requesting Party Token (RPT), or with an RPT that does not grant sufficient permission.

<div class="example">
```http
GET /aggregator/derived-resource-123 HTTP/1.1
Host: agg.example.org
```
</div>

When a Client requests access to a derived resource from the Aggregator Service, a normal UMA flow follows.

**1.1 Aggregator Service requests UMA ticket from its Authorization Server**
The Aggregator Service, acting as a UMA Resource Server, requests a UMA ticket for the requested derived resource from its Authorization Server.
The Aggregator includes the internal identifier of the derived resource in the permission request.
During ticket creation, the Aggregator SHOULD validate that the `derivation_resource_id` used to create the derived resource is still valid.
This validation can be delegated to the Authorization Server by including the `derivation_resource_id` (and its `issuer`) in the permission request, so that the Authorization Server can verify it with the upstream Authorization Server.

If the `derivation_resource_id` is still valid, the Authorization Server returns a UMA ticket as usual.
If it is no longer valid (for example, because the upstream Authorization Server has removed the referenced resource), the Aggregator MUST treat the derived resource as invalid and MUST recreate the Aggregator Service (including its resource registrations).

**1.2 Aggregator Service returns 401 Unauthorized with ticket**
If the Client did not present a valid RPT, or if the RPT does not cover the requested permission, the Aggregator Service returns a `401 Unauthorized` response containing the UMA ticket issued by its Authorization Server.

<div class="example">
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="aggregator", as_uri="https://agg-as.example.org/uma", ticket="tkt-A2"
```
</div>

**2. Client presents ticket to Aggregator Authorization Server**
The Client discovers the Aggregator Authorization Server (for example, via the `as_uri` parameter in the `WWW-Authenticate` header) and sends a UMA grant request to exchange the ticket for an RPT.
The Client includes any claim tokens it already has (for example, its ID token) in the request.

<div class="example">
```json
{
  "grant_type": "urn:ietf:params:oauth:grant-type:uma-ticket",
  "ticket": "tkt-A2",
  "claim_tokens": [
    {
      "claim_token": "OIDC_token",
      "claim_token_format": "http://openid.net/specs/openid-connect-core-1_0.html#IDToken"
    }
  ]
}
```
</div>

**2.1 Aggregator Authorization Server introspects Client access tokens**
The Aggregator Authorization Server validates the claim tokens (for example, by introspecting access tokens and/or verifying ID tokens) and evaluates its authorization policies for the requested derived resource.

**2.2 Aggregator Authorization Server returns need_info (if upstream access is required)**
If access to the derived resource depends on access to upstream resources, and the Client has not yet presented suitable upstream access tokens, the Aggregator Authorization Server MAY respond with a `need_info` error requesting additional claim tokens for the upstream resources.
In that case, the Authorization Server MUST add the `issuer`, `derivation_resource_id`, and `resource_scopes` entries to the `required_claims` array to indicate which upstream Authorization Server and which resource the Client must obtain access to.

- **`issuer`:** identifies the upstream Authorization Server.
- **`derivation_resource_id`:** contains the identifier (or identifiers) provided when the Aggregator Service requested an upstream access token.
- **`resource_scopes`:** list enumerates the scopes required to access the upstream resource and MUST include a derivation scope.

<div class="example">
```json
{
  "error": "need_info",
  "ticket": "tkt-A2",
  "required_claims": [
    {
      "claim_token_format": "urn:ietf:params:oauth:token-type:access_token",
      "details": {
        "issuer": "https://a.example.org",
        "derivation_resource_id": "handle-id-1",
        "resource_scopes": [ "urn:knows:uma:scopes:derivation-read" ]
      }
    }
  ]
}
```
</div>

**3. Client requests upstream access tokens**
The Client SHOULD then request access tokens from the Authorization Server of the upstream Resource Server with the required scopes, including the derivation scope indicated in the `required_claims`.

<div class="example">
```json
{
  "grant_type": "urn:ietf:params:oauth:grant-type:uma-ticket",
  "permissions": [
    {
      "resource_id": "handle-id-1",
      "scopes": [ "urn:knows:uma:scopes:derivation-read" ]
    }
  ],
  "claim_token": "OIDC_token",
  "claim_token_format": "http://openid.net/specs/openid-connect-core-1_0.html#IDToken"
}
```
</div>

**4. Client presents upstream tokens to Aggregator Authorization Server**
Once the Client has obtained the required upstream access tokens, it sends another UMA grant request to the Aggregator Authorization Server, presenting both its ID token and the upstream access tokens as claim tokens together with the original Aggregator ticket.

<div class="example">
```json
{
  "grant_type": "urn:ietf:params:oauth:grant-type:uma-ticket",
  "ticket": "tkt-A2",
  "claim_tokens": [
    {
      "claim_token": "OIDC_token",
      "claim_token_format": "http://openid.net/specs/openid-connect-core-1_0.html#IDToken"
    },
    {
      "claim_token_format": "urn:ietf:params:oauth:token-type:access_token",
      "claim_token": "as-at-2"
    }
  ]
}
```
</div>

The Aggregator Authorization Server MUST verify the provided access tokens with the upstream Authorization Servers to confirm that the Client is authorized to access the upstream resources.
If all policy checks succeed, the Aggregator Authorization Server issues an RPT for the requested derived resource.

**5. Client requests derived resource from Aggregator Service with RPT**
Finally, the Client retries the original request to the Aggregator Service, this time including the RPT it obtained from the Aggregator Authorization Server.
The Aggregator Service validates or introspects the RPT and, if it is active and grants the required permissions, returns the derived resource to the Client.

<div class="example">
```http
GET /aggregator/derived-resource-123 HTTP/1.1
Host: agg.example.org
Authorization: Bearer RPT-agg-1
```
</div>

The Aggregator MAY implement the SA4DS specification to guard endpoints with streaming or other non-HTTP based interfaces.



Aggregator Status Endpoint {#aggregator-status-endpoint}
==================================================

ISSUE: TODO allow this to be json-ld with more semantics?

The Aggregator Status Endpoint (`./{aggregator-id}/status`) allows clients to retrieve the current status of their aggregator.
This endpoint MUST be guarded by the authentication and authorization mechanisms described in the [[#authentication]].
The endpoint MUST return the following information about the aggregator, but additional fields MAY be included as needed:
**- identifier:** (string) The unique identifier of the aggregator.
**- created_at:** (datetime) The timestamp when the aggregator was created.
**- login_status:** (boolean) Indicates whether the token of the aggregator is currently valid.
**- token_expiry:** (datetime) The timestamp when the aggregator's token will expire.



Configuration Endpoint {#configuration-endpoint}
==================================

The Configuration Endpoint gives an authenticated client a complete view on the Aggregator: it exposes the transformations that can be used to assemble a pipeline and it lets the client create, inspect, and remove concrete Aggregator Services (called _actors_ in the reference implementation). 
All configuration routes:

- MUST be protected by the authentication and authorization mechanisms defined in [[#authentication]]; an unauthorized request MUST fail before reaching the handler.
- MUST answer CORS preflight requests by responding to `OPTIONS` with `204 No Content` and the permissive `Access-Control-Allow-*` headers shown in the reference implementation (`Authorization` MUST be listed in `Access-Control-Allow-Headers`).
- MUST respond with JSON using `Content-Type: application/json` unless explicitly stated otherwise.

`/config/transformations` — Available Transformations {#config-transformations}
-------------------------------

The `/config/transformations` resource is an extention on the public `/transformations` endpoint defined in [[#transformations]].
It allows clients to discover which transformations are available.
This endpoint, contrasting to the public `/transformations`, MAY be user specific and MUST require authentication.
A client SHOULD combinge the information from this endpoint with the public `/transformations` endpoint to get a complete view on the available transformations.
The endpoint follows the same content negotiation rules and other requirements as the public `/transformations` endpoint.

`/config/services` — Service Collection {#config-services}
-------------------------------

`/config/services` represents the collection of configured Aggregator Services.
The Aggregator MUST register this UMA resource with the Authorization Server and advertise the `read` and `create` scopes so that clients can both inspect and add members.

: `HEAD`
:: Returns the collection metadata. The server MUST respond with `200 OK`, `Content-Type: application/json`, and an `ETag` header whose value increases whenever a service is added or removed. The `ETag` allows clients to detect collection changes without re-downloading it.

: `GET`
:: Returns the current list of service identifiers. The payload MUST be a JSON object with a `services` array that only contains strings, and SHOULD expose JSON-LD semantics by referencing the Aggregator vocabulary defined in [[#vocabulary]]. Example:

    ```json
    {
      "@context": {
        "id": "@id",
        "services": {
          "@id": "https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/service",
          "@container": "@set",
          "@type": "@id"
        },
        "aggregator": "https://aggregator.example.org/"
      },
      "id": "https://aggregator.example.org/config/services",
      "services": [
        "urn:uuid:410b093c-04b3-4fac-87be-4d393f40b2e5",
        "aggregator:service/42"
      ]
    }
    ```
    The server MUST set the same `ETag` value as the `HEAD` response.

: `POST`
:: Creates a new service. 
    The request body MUST contain a pipeline description that references the available transformations (implementations MAY decide on the exact media type). 
    Upon successful creation the server MUST

      1. Persist the new service and increment the collection `ETag`.
      2. Register a new UMA resource for `/config/services/{service_id}` with the `read` and `delete` scopes so the creator—or any other party with an RPT containing those scopes—can manage the service.
      3. Return `201 Created`, set `Content-Type: application/json`, and include the full JSON representation of the service in the response body.

    If the request body is invalid the server MUST respond with `400 Bad Request`. Failures while instantiating the service MUST result in `500 Internal Server Error`.

`/config/services/{service_id}` — Individual Service {#config-services-service-id}
-------------------------------

Operations on an individual service require the `read` and `delete` scopes. The path component `{service_id}` MUST exactly match one of the identifiers returned by the collection resource; a request for a non-existent service MUST return `404 Not Found`, while malformed paths MUST yield `400 Bad Request`.

: `HEAD`
:: Returns the service metadata. The server MUST respond with `200 OK` and `ETag`, and `Content-Type` headers whose value MUST change whenever the service state changes.

: `GET`
:: A JSON representation of the service MUST be returned with `200 OK` and `Content-Type: application/json`.
    These representations SHOULD include a JSON-LD context that maps the `aggr:` terms defined in [[#vocabulary]] so clients can consume typed data, and content negotiation SHOULD be supported.
    The representation MUST include at least the following fields:
    - **id:** The service identifier.
    - **status:** The current status of the service (e.g., "running", "stopped", "error").
    - **transformation:** The transformation used by the service.
    - **created_at:** Timestamp of when the service was created.
    - **location:** URL where the service can be accessed.


: `DELETE`
:: Stops and removes the service.
    The Aggregator MUST stop the running pipeline, delete the persisted service entry, increment the collection `ETag`, unregister the `/config/services/{service_id}` UMA resource, and respond with `200 OK`.
    Clients that held the service identifier MUST treat it as invalid after receiving the success response.

ISSUE: The exact JSON shape of a service is still implementation-defined. Future revisions of this specification will describe the fields that MUST be present in the service representation and how they relate to the transformation catalog.



Service Lifecycle {#service-lifecycle}
================

This section gives some examples on how a client can create, find, use and delete services on the Aggregator.
This section is non-normative, and is only meant to illustrate the usage of the various endpoints defined in this specification.
This section assumes the client has already created an Aggregator using the Registration Endpoint ([[#registration-endpoint]]) and is able to authenticate using the mechanisms defined in [[#authentication]].

Creating a Service {#creating-a-service}
-----------------

To create a new Aggregator Service, a client starts by doing a POST request to the `/config/services` endpoint.
The contents will be detailed later as this request fails due to missing authentication.

<div class="example">
```http
POST /config/actors HTTP/1.1
Host: aggregator.example.org
Content-Type: application/json
{
    ...
}
```
</div>

The Aggregator fetches a ticket from the Authorization Server with the resource_id `1a2b-creation-endpoint` it got during asset creation.

<div class="example">
```http
HTTP/1.1 /ticket
Host: as.example.org
Content-Type: application/json
{
    "resource_id": "1a2b-creation-endpoint",
    "resource_scopes": ["https://example.org/modes/create"]
}
```
</div>

This returns a ticket that discribes the request done to the RS (the Aggregator in this case).

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json
{
    "ticket": "ticket-1"
}
```
</div>

This ticket is then returned to the client in a `401 Unauthorized` response.

<div class="example">
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="example", as_uri="https://as.example.org", ticket="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```
</div>

The client then requests an RPT from the AS using the ticket.
The original request can then be retried, this time including the RPT in the `Authorization` header.

<div class="example">
```http
POST /config/services HTTP/1.1
Host: aggregator.example.org
Authorization: Bearer ey...
Content-Type: text/turtle

@prefix trans: <http://aggregator.example.org/transformations>
@prefix fno: <https://w3id.org/function/ontology#>

_:execution a fno:Execution ;
    fno:executes trans:AggregateSources ;
    trans:sources ( <http://example.org/source/1> <http://example.org/source/2> ) .
```
</div>

If the request is valid, the Aggregator will create a new service, register the appropriate UMA resource, and return a `201 Created` response with the service representation in the body.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/ld+json
{
    "@context": {
        "id": "@id",
        "type": "@type",
        "Service": "https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/Service",
        "status": "https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/status",
        "created_at": {
            "@id": "https://www.w3.org/ns/prov#generatedAtTime",
            "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
        },
        "location": {
            "@id": "https://schema.org/url",
            "@type": "@id"
        },
        "transformation": {
            "@id": "https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/transformation",
            "@context": {
                "id": "@id",
                "type": "@type",
                "fno": "https://w3id.org/function/ontology#",
                "trans": "http://aggregator.example.org/transformations#",
                "Execution": "fno:Execution",
                "executes": {
                    "@id": "fno:executes",
                    "@type": "@id"
                },
                "sources": {
                    "@id": "trans:sources",
                    "@container": "@list",
                    "@type": "@id"
                }
            }
        }
    },
    "id": "410b093c-04b3-4fac-87be-4d393f40b2e5",
    "type": "Service",
    "status": "running",
    "transformation": {
        "type": "Execution",
        "executes": "trans:AggregateSources",
        "sources": [
            "http://example.org/source/1",
            "http://example.org/source/2"
        ]
    },
    "created_at": "2024-01-01T12:00:00Z",
    "location": "https://aggregator.example.org:35604"
}
```
</div>

As a complex example the resulting service could be an aggregator that combines multiple data sources into a single output stream available at the `location` URL.
For exmple this could be a kafka stream.



Vocabulary {#vocabulary}
===========================

The Aggregator vocabulary is defined in the `aggr:` namespace (`https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/`).
The following classes and properties are used throughout this specification.

Classes {#aggr-vocabulary-classes}
---------------------------

### aggr:Service ### {#aggr-service-class}
Represents a configured Aggregator pipeline that can be created, inspected, and removed via `/config/services/{service_id}`.

**type:** [rdfs:Class](https://www.w3.org/TR/rdf-schema/#ch_class)<br>
**subClassOf:** [prov:Activity](https://www.w3.org/TR/prov-o/#Activity)

### aggr:ServiceCollection ### {#aggr-service-collection-class}
Describes the `/config/services` collection and the metadata returned when listing configured services.

**type:** [rdfs:Class](https://www.w3.org/TR/rdf-schema/#ch_class)<br>
**subClassOf:** [schema:Collection](https://schema.org/Collection), [hydra:Collection](https://www.hydra-cg.com/spec/latest/core/#collections)

Properties {#aggr-vocabulary-properties}
---------------------------

### aggr:service ### {#aggr-service-property}
Links an `aggr:ServiceCollection` to the `aggr:Service` instances it advertises.

**type:** [rdf:Property](https://www.w3.org/TR/rdf-schema/#ch_property)<br>
**domain:** `aggr:ServiceCollection`<br>
**range:** `aggr:Service`

### aggr:status ### {#aggr-status-property}
Provides the lifecycle phase of an `aggr:Service` (values such as `running`, `stopped`, or `error`).

**type:** [rdf:Property](https://www.w3.org/TR/rdf-schema/#ch_property)<br>
**domain:** `aggr:Service`<br>
**range:** [xsd:string](https://www.w3.org/TR/xmlschema11-2/#string)

### aggr:transformation ### {#aggr-transformation-property}
Associates an `aggr:Service` with the FnO execution graph that describes how inputs are transformed.

**type:** [rdf:Property](https://www.w3.org/TR/rdf-schema/#ch_property)<br>
**domain:** `aggr:Service`<br>
**range:** [fno:Execution](https://w3id.org/function/spec/#execution)

Example {#aggr-vocabulary-example}
-------

```turtle
@prefix aggr: <https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/> .
@prefix fno:  <https://w3id.org/function/ontology#> .
@prefix hydra: <http://www.w3.org/ns/hydra/core#> .
@prefix prov: <https://www.w3.org/ns/prov#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <https://schema.org/> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

aggr:Service a rdfs:Class ;
    rdfs:subClassOf prov:Activity .

aggr:ServiceCollection a rdfs:Class ;
    rdfs:subClassOf schema:Collection , hydra:Collection .

aggr:service a rdf:Property ;
    rdfs:domain aggr:ServiceCollection ;
    rdfs:range aggr:Service .

aggr:status a rdf:Property ;
    rdfs:domain aggr:Service ;
    rdfs:range xsd:string .

aggr:transformation a rdf:Property ;
    rdfs:domain aggr:Service ;
    rdfs:range fno:Execution .
```

